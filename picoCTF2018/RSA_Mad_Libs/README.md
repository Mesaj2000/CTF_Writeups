When we run the netcat, we get the following: 
```
0x7069636f4354467b64305f755f6b6e30775f7468335f7740795f325f5253405f63363732343931367dL <type 'long'>
Hello, Welcome to RSA Madlibs
Keeping young children entertained, since, well, nev3r
Tell us how to fill in the blanks, or if it's even possible to do so
Everything, input and output, is decimal, not hex
#### NEW MADLIB ####
q : 93187
p : 94603
##### WE'RE GONNA NEED THE FOLLOWING ####
n
IS THIS POSSIBLE and FEASIBLE? (Y/N):
```

As the name would suggest, this challenge involves RSA encryption.
Each question consists of the following content
1. A series of known values
2. An unknown value
3. The question, "is it possible and feasible to extract the unknown value from the known value?"
4. If yes, "what is the unknown value"?

All of these questions are based on the following relationships found in RSA encryption:
```
p and q are prime numbers
n = p * q
p and q can NOT be feasibly extracted from n, provided n is suitably large
totient(n) = (p-1) * (q-1)
ciphertext = (plaintext ^ e) mod n
d = modular inverse of e mod totient(n)
plaintext = (ciphertext ^ d) mod n
```
Using these relationships, it is reletively simple to answer the first few questions.
(Note: The questions are always exactly the same with each run of the program)
```
Question 1:
q = 93187
p = 94603
n = ? 

Answer: p * q = 8815769761
```

```
Question 2:
p = 81203
n = 6315400919
q = ? 

Answer: n / p = 77773
```

```
Question 3:
e = 3
n = 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522491988970297957869691242321388697846262025013661359752238272878123262505771486253608876989306255043343258045163788244770979622170647023962529229798876649374620968488084311113817060003988811240441131097475853260266167754944587948695842171915048619846282873769413489072243477764350071787327913
p = ?
q = ?

Answer: NOT FEASIBLE
```

```
Question 4:
q = 78203
p = 79999
totient(n) = ?

Answer: (p-1) * (q-1) = 6256003596
```

```
Question 5: 
plaintext = 181590718171647480513645206179391768400087191199885141086479707891116193343133763277482980620010341709624631317220940851114914911751279825748
e = 3
n = 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207474993608282378975862780684198755175430135453698717041597181053546908027266457106990299367542656543819296562625771747985836975450261517377351408743750453299414263220790650107983503705279730669089160055932167392087545369179876065657214225826997676844000054327141666320553082128424707948750331
ciphertext = ?

Answer: (plaintext ^ e) mod n = 26722917505435451150596710555980625220524134812001687080485341361511207096550823814926607028717403343344600191255790864873639087129323153797404989216681535785492257030896045464472300400447688001563694767148451912130180323038978568872458130612657140514751874493071944456290959151981399532582347021031424096175747508579453024891862161356081561032045394147561900547733602483979861042957169820579569242714893461713308057915755735700329990893197650028440038700231719057433874201113850357283873424698585951160069976869223244147124759020366717935504226979456299659682165757462057188430539271285705680101066120475874786208053
```
You can just use the python pow() function with three arguments.


```
Question 6:
ciphertext = 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323
e = 3
n = 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359
plaintext = ?

Answer: NOT FEASIBLE
```
You cannot extract plaintext from ciphertext without d,
which requires totient(n), which requires p and q,
which cannot be feasibly extracted from n (same as question 3)


```
Question 7:
q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
e = 65537
d = ?

Answer: modinverse(e, (p-1) * (q-1)) = 1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729
```
For modinverse, you can use gmpy2.invert

```
Question 8:
p = 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
ciphertext = 14699632914289984358210582075909309608817619615764122409514577850253033131275996955127394794512801987443786025277031557775238937388086632327611216460613138074110905840487213116627139558528011448028813522809156509374602431319619052803531008581645459969997969897966475478980398396687104746302415391434104278327526947341073215599683555703818611403510483832532921625745935543818100178607417658929607435582550913918895885596025822532531372429301293588416086854338617700672628239475365045267537032531973594689061842791028000992635092519215619497247452814483357403667400283975070444902253349175045305073603687442947532925780
e = 65537
n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239

plaintext = ?
```
This is the final question, and it's the culmination of everything we've learned so far.
To solve it, you need to:
1. Extract q: 
	`n / p`
2. Determine totient(n): 
	`(p-1) * (q-1)`
3. Determine d: 
	`modinv(e, totient(n))`
4. Determine plaintext: 
	`(ciphertext ^ d) mod n`

Each step is a problem we've solved before: (2, 4, 7, and 5).

Here's a [script](RSAMadLibsSolution.py) to put it all together, for an answer of:
```
240109877286251840533272915662757983981706320845661471802585807564915966910385147086109038271870589
```

To recap, the full set of correct inputs are:
```
y
8815769761
y
77773
n
y
6256003596
y
26722917505435451150596710555980625220524134812001687080485341361511207096550823814926607028717403343344600191255790864873639087129323153797404989216681535785492257030896045464472300400447688001563694767148451912130180323038978568872458130612657140514751874493071944456290959151981399532582347021031424096175747508579453024891862161356081561032045394147561900547733602483979861042957169820579569242714893461713308057915755735700329990893197650028440038700231719057433874201113850357283873424698585951160069976869223244147124759020366717935504226979456299659682165757462057188430539271285705680101066120475874786208053
n
y
1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729
y
240109877286251840533272915662757983981706320845661471802585807564915966910385147086109038271870589
```
Once you've successfully input all of these, the netcat reads:
```
If you convert the last plaintext to a hex number, then ascii, you'll find what you're searching for ;)
```
Doing so gives the flag: `picoCTF{d0_u_kn0w_th3_w@y_2_RS@_c6724916}`
The included script does the conversion automatically.


