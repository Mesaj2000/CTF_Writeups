The problem simply givies a file, [ciphertext](ciphertext.txt), with a few RSA variables: n, e, and ciphertext.
```
N: 374159235470172130988938196520880526947952521620932362050308663243595788308583992120881359365258949723819911758198013202644666489247987314025169670926273213367237020188587742716017314320191350666762541039238241984934473188656610615918474673963331992408750047451253205158436452814354564283003696666945950908549197175404580533132142111356931324330631843602412540295482841975783884766801266552337129105407869020730226041538750535628619717708838029286366761470986056335230171148734027536820544543251801093230809186222940806718221638845816521738601843083746103374974120575519418797642878012234163709518203946599836959811
e: 3

ciphertext (c): 2205316413931134031046440767620541984801091216351222789180573437837873413848819848972069088625959518346568495824756225842751786440791759449675594790690830246158935538568387091288002447511390259320746890980769089692036188995150522856413797 
```
RSA variables are all related through a series of equations. The one were most interested in today is:
```
ciphertext = (plaintext ^ e) mod n
```
Solving for plaintext gives:
```
c = p^e % n
c + xn = p^e
p = root(e, c + xn)
```
Where `x` is any constant integer.
(This is true for literally any RSA)


There are two important things to note about this particular set of values:
1. "mod n" can produce a value anywhere from 0 to n-1, which would tend to have a number of digits closer to n than 0. However, c is suspiciously short relative to n.
2. e is extremly small.


Normally, doing a brute force check for all possible values of x would be a terrible idea, but because of these two facts, it should be fine. In fact, it turns out x is actually 0.


Once you get plaintext, its just a matter of converting it to hex, then ascii:
```
picoCTF{e_w4y_t00_sm411_7815e4a7}
```

Here's a [script](SafeRSASolution.py) that puts it all toghether:
```
from gmpy2 import iroot

n = 374159235470172130988938196520880526947952521620932362050308663243595788308583992120881359365258949723819911758198013202644666489247987314025169670926273213367237020188587742716017314320191350666762541039238241984934473188656610615918474673963331992408750047451253205158436452814354564283003696666945950908549197175404580533132142111356931324330631843602412540295482841975783884766801266552337129105407869020730226041538750535628619717708838029286366761470986056335230171148734027536820544543251801093230809186222940806718221638845816521738601843083746103374974120575519418797642878012234163709518203946599836959811
e = 3
c = 2205316413931134031046440767620541984801091216351222789180573437837873413848819848972069088625959518346568495824756225842751786440791759449675594790690830246158935538568387091288002447511390259320746890980769089692036188995150522856413797

x = 0
while iroot(c + x*n, e)[1] == False: 
	x += 1
	
plain = hex(iroot(c + x*n, e)[0])[2:].decode("hex")

print(plain)
```
